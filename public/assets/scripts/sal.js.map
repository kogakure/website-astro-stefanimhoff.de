{"version":3,"sources":["webpack://sal/webpack/universalModuleDefinition","webpack://sal/webpack/bootstrap","webpack://sal/webpack/runtime/define property getters","webpack://sal/webpack/runtime/hasOwnProperty shorthand","webpack://sal/./src/sal.js"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","SSR_MESSAGE","NOT_SUPPORTED_MESSAGE","options","rootMargin","threshold","animateClassName","disabledClassName","enterEventName","exitEventName","selector","once","disabled","elements","intersectionObserver","setOptions","settings","clearAnimation","element","classList","remove","fireEvent","name","entry","event","CustomEvent","bubbles","detail","target","dispatchEvent","disableAnimations","document","body","add","clearObserver","disconnect","isDisabled","onIntersection","entries","observer","forEach","hasRepeatFlag","undefined","dataset","salRepeat","hasOnceFlag","salOnce","shouldRepeat","intersectionRatio","animate","unobserve","reverse","getObservedElements","collection","filter","querySelectorAll","contains","isAnimated","observe","disable","enable","IntersectionObserver","reset","Array","from","update","newElements","push","window","console","warn","Error"],"mappings":"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","file":"sal.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sal\"] = factory();\n\telse\n\t\troot[\"sal\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * Sal - Scroll Animation Library\n * Performance focused, lightweight scroll animation library\n */\n\nimport './sal.scss';\n\nconst SSR_MESSAGE = 'Sal was not initialised! Probably it is used in SSR.';\n\nconst NOT_SUPPORTED_MESSAGE = ''\n  + 'Your browser does not support IntersectionObserver!\\n'\n  + 'Get a polyfill from here:\\n'\n  + 'https://github.com/w3c/IntersectionObserver/tree/master/polyfill';\n\n/**\n * Default options\n */\nlet options = {\n  root: null,\n  rootMargin: '0% 50%',\n  threshold: 0.5,\n  animateClassName: 'sal-animate',\n  disabledClassName: 'sal-disabled',\n  enterEventName: 'sal:in',\n  exitEventName: 'sal:out',\n  selector: '[data-sal]',\n  once: true,\n  disabled: false,\n};\n\n/**\n * Private\n */\nlet elements = [];\nlet intersectionObserver = null;\n\n/**\n * Sets options.\n * @param {Object} settings\n */\nconst setOptions = (settings) => {\n  if (settings && settings !== options) {\n    options = {\n      ...options,\n      ...settings,\n    };\n  }\n};\n\n/**\n * Clears animation for given element.\n * @param {HTMLElement} element\n */\nconst clearAnimation = (element) => {\n  element.classList.remove(options.animateClassName);\n};\n\n/**\n * Dispatches the animate event on the intersection observer entry.\n * @param {IntersectionObserverEntry} detail The entry to fire event on.\n */\nconst fireEvent = (name, entry) => {\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    detail: entry,\n  });\n\n  entry.target.dispatchEvent(event);\n};\n\n/**\n * Launches animation by adding class.\n * @param {IntersectionObserverEntry} entry\n */\nconst animate = (entry) => {\n  entry.target.classList.add(options.animateClassName);\n  fireEvent(options.enterEventName, entry);\n};\n\n/**\n * Reverses animation by removing class.\n * @param {IntersectionObserverEntry} entry\n */\nconst reverse = (entry) => {\n  clearAnimation(entry.target);\n  fireEvent(options.exitEventName, entry);\n};\n\n/**\n * Checks if element was animated.\n * @param {HTMLElement} element\n */\nconst isAnimated = (element) => (\n  element.classList.contains(options.animateClassName)\n);\n\n/**\n * Enables animations by remove class from body.\n */\nconst enableAnimations = () => {\n  document.body.classList.remove(options.disabledClassName);\n};\n\n/**\n * Disables animations by add class from body.\n */\nconst disableAnimations = () => {\n  document.body.classList.add(options.disabledClassName);\n};\n\n/**\n * Clears observer.\n */\nconst clearObserver = () => {\n  intersectionObserver.disconnect();\n  intersectionObserver = null;\n};\n\n/**\n * Check if should be disabled.\n * @return {Boolean}\n */\nconst isDisabled = () => (\n  options.disabled\n  || (\n    (typeof options.disabled === 'function')\n    && options.disabled()\n  )\n);\n\n/**\n * IntersectionObserver callback.\n * @param  {Array<IntersectionObserverEntry>} entries\n * @param  {IntersectionObserver} observer\n */\nconst onIntersection = (entries, observer) => {\n  entries.forEach((entry) => {\n    const { target } = entry;\n    const hasRepeatFlag = target.dataset.salRepeat !== undefined;\n    const hasOnceFlag = target.dataset.salOnce !== undefined;\n    const shouldRepeat = hasRepeatFlag || !(hasOnceFlag || options.once);\n\n    if (entry.intersectionRatio >= options.threshold) {\n      animate(entry);\n\n      if (!shouldRepeat) {\n        observer.unobserve(target);\n      }\n    } else if (shouldRepeat) {\n      reverse(entry);\n    }\n  });\n};\n\n/**\n * Returns collection of elements and pushes them to observer.\n *\n * @returns {Array<Node>}\n */\nconst getObservedElements = () => {\n  const collection = [].filter.call(\n    document.querySelectorAll(options.selector),\n    (element) => !isAnimated(element, options.animateClassName),\n  );\n\n  collection.forEach((element) => intersectionObserver.observe(element));\n\n  return collection;\n};\n\n/**\n * Disables instance by removing animations and clearing observer.\n */\nconst disable = () => {\n  disableAnimations();\n  clearObserver();\n};\n\n/**\n * Enables instance by launching new IntersectionObserver.\n */\nconst enable = () => {\n  enableAnimations();\n\n  intersectionObserver = new IntersectionObserver(onIntersection, {\n    root: options.root,\n    rootMargin: options.rootMargin,\n    threshold: options.threshold,\n  });\n\n  elements = getObservedElements();\n};\n\n/**\n * Resets instance to provide new settings.\n * @param {Object} settings\n */\nconst reset = (settings = {}) => {\n  clearObserver();\n\n  Array.from(document.querySelectorAll(options.selector))\n    .forEach(clearAnimation);\n\n  setOptions(settings);\n  enable();\n};\n\n/**\n * Updates observer with new elements to animated.\n * Useful for dynamically injected elements.\n */\nconst update = () => {\n  const newElements = getObservedElements();\n  elements.push(newElements);\n};\n\n/**\n * Init\n * @param  {Object} settings\n * @return {Object} public API\n */\nconst init = (settings = options) => {\n  setOptions(settings);\n\n  // Early return, when window object is not defined\n  // e.g. during Server Side Rendering\n  if (typeof window === 'undefined') {\n    // eslint-disable-next-line no-console\n    console.warn(SSR_MESSAGE);\n\n    return {\n      elements,\n      disable,\n      enable,\n      reset,\n      update,\n    };\n  }\n\n  if (!window.IntersectionObserver) {\n    disableAnimations();\n\n    throw Error(NOT_SUPPORTED_MESSAGE);\n  }\n\n  if (!isDisabled()) {\n    enable();\n  } else {\n    disableAnimations();\n  }\n\n  return {\n    elements,\n    disable,\n    enable,\n    reset,\n    update,\n  };\n};\n\nexport default init;\n"],"sourceRoot":""}